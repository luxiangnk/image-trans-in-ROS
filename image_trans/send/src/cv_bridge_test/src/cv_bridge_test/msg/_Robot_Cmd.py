"""autogenerated by genpy from cv_bridge_test/Robot_Cmd.msg. Do not edit."""
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class Robot_Cmd(genpy.Message):
  _md5sum = "d1592935135b0c5843f583423d639699"
  _type = "cv_bridge_test/Robot_Cmd"
  _has_header = False #flag to mark the presence of a Header object
  _full_text = """int32   cmd_id
float64 cmd_flag
int32   hand_num
int32   joint_num
float64 target_rst1
float64 target_rst2
float64 target_rst3
float64 target_rst4
float64 target_lst1
float64 target_lst2
float64 target_lst3
float64 target_lst4
float64[] target_positionx
float64[] target_positiony
float64[] target_positionst


"""
  __slots__ = ['cmd_id','cmd_flag','hand_num','joint_num','target_rst1','target_rst2','target_rst3','target_rst4','target_lst1','target_lst2','target_lst3','target_lst4','target_positionx','target_positiony','target_positionst']
  _slot_types = ['int32','float64','int32','int32','float64','float64','float64','float64','float64','float64','float64','float64','float64[]','float64[]','float64[]']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       cmd_id,cmd_flag,hand_num,joint_num,target_rst1,target_rst2,target_rst3,target_rst4,target_lst1,target_lst2,target_lst3,target_lst4,target_positionx,target_positiony,target_positionst

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(Robot_Cmd, self).__init__(*args, **kwds)
      #message fields cannot be None, assign default values for those that are
      if self.cmd_id is None:
        self.cmd_id = 0
      if self.cmd_flag is None:
        self.cmd_flag = 0.
      if self.hand_num is None:
        self.hand_num = 0
      if self.joint_num is None:
        self.joint_num = 0
      if self.target_rst1 is None:
        self.target_rst1 = 0.
      if self.target_rst2 is None:
        self.target_rst2 = 0.
      if self.target_rst3 is None:
        self.target_rst3 = 0.
      if self.target_rst4 is None:
        self.target_rst4 = 0.
      if self.target_lst1 is None:
        self.target_lst1 = 0.
      if self.target_lst2 is None:
        self.target_lst2 = 0.
      if self.target_lst3 is None:
        self.target_lst3 = 0.
      if self.target_lst4 is None:
        self.target_lst4 = 0.
      if self.target_positionx is None:
        self.target_positionx = []
      if self.target_positiony is None:
        self.target_positiony = []
      if self.target_positionst is None:
        self.target_positionst = []
    else:
      self.cmd_id = 0
      self.cmd_flag = 0.
      self.hand_num = 0
      self.joint_num = 0
      self.target_rst1 = 0.
      self.target_rst2 = 0.
      self.target_rst3 = 0.
      self.target_rst4 = 0.
      self.target_lst1 = 0.
      self.target_lst2 = 0.
      self.target_lst3 = 0.
      self.target_lst4 = 0.
      self.target_positionx = []
      self.target_positiony = []
      self.target_positionst = []

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_struct_id2i8d.pack(_x.cmd_id, _x.cmd_flag, _x.hand_num, _x.joint_num, _x.target_rst1, _x.target_rst2, _x.target_rst3, _x.target_rst4, _x.target_lst1, _x.target_lst2, _x.target_lst3, _x.target_lst4))
      length = len(self.target_positionx)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.target_positionx))
      length = len(self.target_positiony)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.target_positiony))
      length = len(self.target_positionst)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.pack(pattern, *self.target_positionst))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(_x))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(_x))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    try:
      end = 0
      _x = self
      start = end
      end += 84
      (_x.cmd_id, _x.cmd_flag, _x.hand_num, _x.joint_num, _x.target_rst1, _x.target_rst2, _x.target_rst3, _x.target_rst4, _x.target_lst1, _x.target_lst2, _x.target_lst3, _x.target_lst4,) = _struct_id2i8d.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.target_positionx = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.target_positiony = struct.unpack(pattern, str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.target_positionst = struct.unpack(pattern, str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_struct_id2i8d.pack(_x.cmd_id, _x.cmd_flag, _x.hand_num, _x.joint_num, _x.target_rst1, _x.target_rst2, _x.target_rst3, _x.target_rst4, _x.target_lst1, _x.target_lst2, _x.target_lst3, _x.target_lst4))
      length = len(self.target_positionx)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.target_positionx.tostring())
      length = len(self.target_positiony)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.target_positiony.tostring())
      length = len(self.target_positionst)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.target_positionst.tostring())
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(_x))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(_x))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    try:
      end = 0
      _x = self
      start = end
      end += 84
      (_x.cmd_id, _x.cmd_flag, _x.hand_num, _x.joint_num, _x.target_rst1, _x.target_rst2, _x.target_rst3, _x.target_rst4, _x.target_lst1, _x.target_lst2, _x.target_lst3, _x.target_lst4,) = _struct_id2i8d.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.target_positionx = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.target_positiony = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      end += struct.calcsize(pattern)
      self.target_positionst = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e) #most likely buffer underfill

_struct_I = genpy.struct_I
_struct_id2i8d = struct.Struct("<id2i8d")
